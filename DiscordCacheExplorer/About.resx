<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="RichTextBox1.Text" xml:space="preserve">
    <value>----Cache Explorer----
By LunarHunter 2019

Help:
What is cache?
A cache file has temporary information that a program sets aside because it assumes you'll want to use it again soon. Doing this allows the software to load the information faster and reduces bandwidth costs than it would take to find the original data on servers.

I've encountered an error/exception, what do I do?
Either try again or report to the developer. Report what you were doing before the error and what the error said.

Why is an image/gif/any file corrupted?
From experience, loading an image/gif/file too quickly could result in the program saving the cache file but discards it halfway through due to it not being not shown anymore. So, If you quickly scrolled a webpage down, half the time some of the caches would be corrupted.

Builds:
v1.5:
Updated ToC
Made sure to update app events to show loading label when the user clicked on reload program cache folders.
Added real-time updating (e.g. if an item was added after loading, it will copy the new file to cache and add it to the list without any slowdown)
Added Reload ProgramCacheList.ini just in case the listbox glitches out.
Added Settings (Disabled for now)
Added .error just in case an error occurred in the format-detection

v1.4:
Added Exclude .unknown
Fixed a bug where closing Change Cache Folder while the main form was open would close the entire program.
Fixed a bug where closing the main form didn't close the entire program, causing it to be open in the background doing nothing.
Changed Delete all Cache files to Delete Selected Cache Files.
Added update checker to check for new updates.
When pressing enter on the Change Cache Folder Form Filter, It chooses the topmost item and selects that as the cache folder.
Made ToC look better.

v1.3
Tried to add more locations to scan for cache folders in.
Fixed the Refresh Program List because it wouldn't clear the list but instead just add to it.
Fixed a bug where selecting a new cache folder would not load the specific cache folder in question.
Added ToC (Terms and Conditions).
Changed Font to Arial.
Change minimum size on the main form.

v1.2
Filter boxes now update in real-time, no need to click search.
Added Minimum Size to Change Cache Folder Form.
Fixed Incorrect Anchor.
Removed unused code.
The program now updates while doing tasks like scanning (e.g. when scanning, it will tell you how many files have been scanned and how many are there in total)
Added cache to the Change Cache Folder form to make the program load faster.
The program will now add folders in the programs cache folder to specify where the cache came from (e.g. CacheFiles\Opera\GPUCache\)

v1.1
Changed from build to version because GitHub doesn't allow it.
Change Cache Folder form now checks for all folders in AppData with cache in its name.
Added please wait labels when loading stuff that takes a while.
Added a filter to the Change Cache Folder form.
The program now adds folders in cache to specify where the cache came from (e.g. CacheFiles\Opera\). That way, cache files won't get overwritten.
Added progress bar when scanning cache.

build 1000 (v1.0):
No changes


</value>
  </data>
</root>